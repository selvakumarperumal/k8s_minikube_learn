# ============================================================================
# SIDECAR PATTERN - Log Shipping Example
# ============================================================================
#
# WHAT IS A SIDECAR?
# ------------------
# A sidecar is a helper container that runs alongside your main container
# in the same Pod. They share:
#   - Network namespace (same IP, can use localhost)
#   - Volumes (can share files)
#   - Pod lifecycle (start/stop together)
#
# WHY USE SIDECARS?
# -----------------
# - Separation of concerns (app doesn't need logging logic)
# - Reusability (same sidecar for multiple apps)
# - Independent updates (update logging without touching app)
#
# THIS EXAMPLE INCLUDES:
# ----------------------
# 1. Traditional sidecar (works in all K8s versions)
# 2. Native sidecar (K8s 1.28+ with restartPolicy: Always)
#
# ============================================================================

# =============================================================================
# EXAMPLE 1: TRADITIONAL SIDECAR PATTERN
# =============================================================================
# In traditional sidecars, all containers are defined in 'containers' section
# and start in PARALLEL. This means:
#   - Main app and sidecars start at the same time
#   - Sidecars must handle case where log file doesn't exist yet
#   - No guaranteed startup order

apiVersion: v1
kind: Pod
metadata:
  name: sidecar-traditional
  labels:
    app: sidecar-demo
    type: traditional
spec:
  # ===========================================================================
  # SHARED VOLUME
  # ===========================================================================
  # emptyDir creates an empty directory when Pod starts.
  # All containers that mount this volume can read/write to it.
  # Data is lost when Pod is deleted.
  volumes:
    - name: shared-logs
      emptyDir: {} # Empty directory, shared between containers

  containers:
    # =========================================================================
    # MAIN APPLICATION CONTAINER
    # =========================================================================
    # This is your actual application. In this demo, it generates logs.
    - name: app
      image: busybox:1.35

      # -----------------------------------------------------------------------
      # BASH SCRIPT EXPLANATION
      # -----------------------------------------------------------------------
      # This script runs when the container starts:
      #
      # 1. echo "Application starting..."
      #    â†’ Prints starting message to stdout
      #
      # 2. while true; do ... done
      #    â†’ Infinite loop - keeps container running forever
      #
      # 3. echo "[$(date)] INFO: ..." >> /var/log/app.log
      #    â†’ $(date) = current timestamp
      #    â†’ $RANDOM = random number (0-32767)
      #    â†’ >> = append to file (not overwrite)
      #    â†’ Creates log entries in the shared volume
      #
      # 4. if [ $((RANDOM % 5)) -eq 0 ]; then
      #    â†’ $((expression)) = arithmetic evaluation
      #    â†’ RANDOM % 5 = remainder when dividing by 5 (gives 0-4)
      #    â†’ -eq 0 = equals zero (20% chance)
      #    â†’ Randomly generates ERROR logs for testing
      #
      # 5. sleep 2
      #    â†’ Wait 2 seconds before next iteration
      #
      command:
        - sh # Use shell
        - -c # -c = run the following string as a command
        - | # | = multi-line string (YAML literal block)
          # Print startup message
          echo "Application starting..."

          # Infinite loop to keep container running
          while true; do
            # Generate INFO log with timestamp and random request ID
            # >> means APPEND to file (create if doesn't exist)
            echo "[$(date)] INFO: Processing request $RANDOM" >> /var/log/app.log
            
            # Generate WARN log
            echo "[$(date)] WARN: Cache miss for key-$RANDOM" >> /var/log/app.log
            
            # Randomly generate ERROR (20% chance)
            # $((RANDOM % 5)) gives remainder 0-4
            # If remainder is 0 (happens 1 in 5 times), generate error
            if [ $((RANDOM % 5)) -eq 0 ]; then
              echo "[$(date)] ERROR: Connection timeout!" >> /var/log/app.log
            fi
            
            # Wait 2 seconds before next log
            sleep 2
          done

      # Mount the shared volume at /var/log
      volumeMounts:
        - name: shared-logs # Must match volume name above
          mountPath: /var/log # Path inside container

      # Resource limits - always set for production!
      resources:
        requests:
          cpu: 50m # 0.05 CPU = guaranteed minimum
          memory: 64Mi # 64 MiB = guaranteed minimum
        limits:
          cpu: 100m # 0.1 CPU = maximum allowed
          memory: 128Mi # 128 MiB = maximum allowed

    # =========================================================================
    # SIDECAR 1: LOG SHIPPER
    # =========================================================================
    # Purpose: Read logs from shared volume and ship to external service
    # In real world: Send to Elasticsearch, Splunk, CloudWatch, etc.
    - name: log-shipper
      image: busybox:1.35

      # -----------------------------------------------------------------------
      # BASH SCRIPT EXPLANATION
      # -----------------------------------------------------------------------
      #
      # 1. while [ ! -f /var/log/app.log ]; do ... done
      #    â†’ [ ! -f file ] = true if file does NOT exist
      #    â†’ -f = check if regular file exists
      #    â†’ Wait loop until app.log is created by main app
      #
      # 2. tail -f /var/log/app.log
      #    â†’ tail = show last lines of file
      #    â†’ -f = follow mode (keep watching for new lines)
      #    â†’ Continuously streams new log lines
      #
      # 3. | while read line; do ... done
      #    â†’ | = pipe output to next command
      #    â†’ read line = read each line into variable 'line'
      #    â†’ Process each log line as it arrives
      #
      # 4. echo "[SHIPPED] $line"
      #    â†’ $line = the log line we just read
      #    â†’ In production, replace with: curl -X POST elasticsearch/...
      #
      command:
        - sh
        - -c
        - |
          echo "Log shipper sidecar starting..."

          # Wait for log file to be created by main app
          # The [ ] is a test command
          # ! means NOT
          # -f checks if file exists
          while [ ! -f /var/log/app.log ]; do
            echo "Waiting for app.log to be created..."
            sleep 1
          done

          echo "Found app.log, starting to ship logs..."

          # tail -f follows the file in real-time
          # | pipes output to while loop
          # read line stores each line in variable $line
          tail -f /var/log/app.log | while read line; do
            # In production, this would send to external service:
            # curl -X POST http://elasticsearch:9200/logs/_doc \
            #   -H "Content-Type: application/json" \
            #   -d "{\"message\": \"$line\"}"
            
            # For demo, just print with [SHIPPED] prefix
            echo "[SHIPPED] $line"
          done

      # Same volume mount - reads from where app writes
      volumeMounts:
        - name: shared-logs
          mountPath: /var/log

      resources:
        requests:
          cpu: 50m
          memory: 64Mi
        limits:
          cpu: 100m
          memory: 128Mi

    # =========================================================================
    # SIDECAR 2: LOG ANALYZER
    # =========================================================================
    # Purpose: Monitor logs for errors/warnings and alert
    # In real world: Send alerts to PagerDuty, Slack, etc.
    - name: log-analyzer
      image: busybox:1.35

      # -----------------------------------------------------------------------
      # BASH SCRIPT EXPLANATION
      # -----------------------------------------------------------------------
      #
      # 1. echo "$line" | grep -q "ERROR\|WARN"
      #    â†’ echo outputs the line
      #    â†’ | pipes to grep
      #    â†’ grep searches for pattern
      #    â†’ -q = quiet mode (no output, just exit code)
      #    â†’ "ERROR\|WARN" = match ERROR OR WARN (\| is OR in grep)
      #    â†’ Returns true (exit 0) if found, false (exit 1) if not
      #
      # 2. if ... ; then ... elif ... then ... fi
      #    â†’ if/elif/fi = if/else-if/end
      #    â†’ Check for ERROR first, then WARN
      #
      command:
        - sh
        - -c
        - |
          echo "Log analyzer sidecar starting..."

          # Wait for log file
          while [ ! -f /var/log/app.log ]; do
            sleep 1
          done

          echo "Monitoring for errors and warnings..."

          # tail -f follows file, pipe each line to while loop
          tail -f /var/log/app.log | while read line; do
            # grep -q = quiet mode, just check if pattern exists
            # | in grep means OR (escape with \)
            
            # Check for ERROR (highest priority)
            if echo "$line" | grep -q "ERROR"; then
              # ðŸš¨ emoji for visibility
              echo "[ðŸš¨ ALERT] Error detected: $line"
              # In production: send to PagerDuty, OpsGenie, etc.
              
            # Check for WARN
            elif echo "$line" | grep -q "WARN"; then
              echo "[âš ï¸  WARN] Warning detected: $line"
              # In production: send to Slack channel
            fi
            
            # INFO logs are ignored (no action needed)
          done

      volumeMounts:
        - name: shared-logs
          mountPath: /var/log

      resources:
        requests:
          cpu: 50m
          memory: 64Mi
        limits:
          cpu: 100m
          memory: 128Mi

---
# =============================================================================
# EXAMPLE 2: NATIVE SIDECAR PATTERN (Kubernetes 1.28+)
# =============================================================================
#
# WHAT'S DIFFERENT?
# -----------------
# Native sidecars are defined in 'initContainers' but with:
#   restartPolicy: Always
#
# This tells Kubernetes:
# 1. Start this container first (like normal init container)
# 2. DON'T wait for it to complete (unlike normal init container)
# 3. Keep it running for the life of the Pod
# 4. Start main containers only after sidecars are running
#
# BENEFITS:
# ---------
# - Sidecars are ready BEFORE main app starts
# - No need for "wait for file" loops
# - Proper shutdown order (app stops before sidecars)
# - Better for service mesh proxies (Istio, Linkerd)
#
# REQUIREMENTS:
# -------------
# - Kubernetes 1.28 or later
# - Alpha feature in 1.28, beta in 1.29+

apiVersion: v1
kind: Pod
metadata:
  name: sidecar-native
  labels:
    app: sidecar-demo
    type: native
spec:
  volumes:
    - name: shared-logs
      emptyDir: {}

  # ===========================================================================
  # NATIVE SIDECARS (in initContainers with restartPolicy: Always)
  # ===========================================================================
  # These start FIRST, and main containers wait for them to be RUNNING
  # (not completed, since they have restartPolicy: Always)
  initContainers:
    # -------------------------------------------------------------------------
    # NATIVE SIDECAR 1: Log Shipper
    # -------------------------------------------------------------------------
    - name: log-shipper
      image: busybox:1.35

      # THIS IS THE MAGIC LINE!
      # Normal init containers have restartPolicy: Never (default)
      # Setting it to Always makes it a NATIVE SIDECAR
      restartPolicy: Always

      # -----------------------------------------------------------------------
      # BASH SCRIPT EXPLANATION - WHY IT RUNS INFINITELY
      # -----------------------------------------------------------------------
      #
      # Q: Does this script exit or run forever?
      # A: It runs FOREVER because of `tail -f`
      #
      # HOW IT WORKS:
      # -------------
      # 1. touch /var/log/app.log
      #    â†’ Creates empty file if doesn't exist
      #    â†’ Unlike traditional sidecar, we create file FIRST
      #    â†’ Main app will append to this file later
      #
      # 2. tail -f /var/log/app.log
      #    â†’ -f means "follow" mode
      #    â†’ This command NEVER EXITS on its own!
      #    â†’ It blocks and waits for new lines forever
      #    â†’ Perfect for sidecar that needs to run continuously
      #
      # 3. | while read line; do ... done
      #    â†’ Pipe new lines to while loop
      #    â†’ Each new line triggers the loop body
      #    â†’ Loop keeps waiting for more lines (never exits)
      #
      # 4. [ -z "$line" ] && continue
      #    â†’ [ -z "$var" ] = true if variable is empty
      #    â†’ && = if true, run next command
      #    â†’ continue = skip to next iteration
      #    â†’ This skips empty lines
      #
      # LIFECYCLE:
      # ----------
      # Container starts â†’ tail -f blocks waiting â†’ main app writes logs
      # â†’ tail -f sees new lines â†’ pipes to while loop â†’ processes each line
      # â†’ continues waiting for more lines â†’ runs until Pod is deleted
      #
      command:
        - sh
        - -c
        - |
          echo "Native sidecar: Log shipper starting..."

          # Create log file FIRST (before main app starts)
          # touch = create empty file if doesn't exist
          # Unlike traditional sidecar, we create file proactively
          touch /var/log/app.log

          echo "Log file created, ready to ship..."

          # tail -f = BLOCKING command that runs FOREVER
          # It waits for new lines and never exits!
          # This is what keeps the sidecar running
          tail -f /var/log/app.log | while read line; do
            # Skip empty lines
            # [ -z "$line" ] = true if $line is empty
            # && continue = if true, skip to next iteration
            [ -z "$line" ] && continue
            
            # Process non-empty lines
            echo "[SHIPPED] $line"
            
            # In production: send to Elasticsearch, Splunk, etc.
            # curl -X POST http://elasticsearch:9200/logs/_doc -d "$line"
          done

          # NOTE: We never reach here because tail -f runs forever!
          echo "This line will never be printed!"

      volumeMounts:
        - name: shared-logs
          mountPath: /var/log

      resources:
        requests:
          cpu: 50m
          memory: 64Mi

    # -------------------------------------------------------------------------
    # NATIVE SIDECAR 2: Log Analyzer
    # -------------------------------------------------------------------------
    - name: log-analyzer
      image: busybox:1.35

      restartPolicy: Always # Makes it a native sidecar

      # -----------------------------------------------------------------------
      # BASH SCRIPT EXPLANATION - MONITORING LOOP
      # -----------------------------------------------------------------------
      #
      # This also runs FOREVER because of tail -f
      #
      # PATTERN MATCHING:
      # -----------------
      # echo "$line" | grep -q "ERROR\|WARN"
      #
      # Breakdown:
      #   echo "$line"     â†’ Output the log line
      #   |                â†’ Pipe to grep
      #   grep             â†’ Search for pattern
      #   -q               â†’ Quiet mode (no output, just exit code)
      #   "ERROR\|WARN"    â†’ Pattern: ERROR OR WARN
      #                      \| means OR in grep
      #
      # grep returns:
      #   Exit code 0 (true)  â†’ Pattern found
      #   Exit code 1 (false) â†’ Pattern not found
      #
      # if/fi checks the exit code of grep
      #
      command:
        - sh
        - -c
        - |
          echo "Native sidecar: Log analyzer starting..."

          # File already exists (created by log-shipper sidecar)
          # No need to wait or check!

          # tail -f runs FOREVER, keeping this sidecar alive
          tail -f /var/log/app.log | while read line; do
            # Skip empty lines
            [ -z "$line" ] && continue
            
            # Check if line contains ERROR or WARN
            # grep -q = quiet (no output, just exit code)
            # \| = OR in grep regex
            if echo "$line" | grep -q "ERROR\|WARN"; then
              echo "[ALERT] $line"
              # In production: send to PagerDuty, Slack, etc.
            fi
          done

      volumeMounts:
        - name: shared-logs
          mountPath: /var/log

      resources:
        requests:
          cpu: 50m
          memory: 64Mi

  # ===========================================================================
  # MAIN APPLICATION
  # ===========================================================================
  # This starts AFTER all native sidecars are running
  containers:
    - name: app
      image: busybox:1.35

      command:
        - sh
        - -c
        - |
          echo "=========================================="
          echo "Main application starting..."
          echo "Native sidecars are already running!"
          echo "=========================================="

          # Generate logs - sidecars are already watching!
          while true; do
            echo "[$(date)] INFO: Processing request $RANDOM" >> /var/log/app.log
            
            # Random error (20% chance)
            if [ $((RANDOM % 5)) -eq 0 ]; then
              echo "[$(date)] ERROR: Something went wrong!" >> /var/log/app.log
            fi
            
            sleep 2
          done

      volumeMounts:
        - name: shared-logs
          mountPath: /var/log

      resources:
        requests:
          cpu: 50m
          memory: 64Mi
        limits:
          cpu: 100m
          memory: 128Mi
# ============================================================================
# HOW TO USE
# ============================================================================
#
# APPLY BOTH EXAMPLES:
#   kubectl apply -f sidecar-logging.yaml
#
# CHECK PODS:
#   kubectl get pods
#   # You'll see:
#   # sidecar-traditional   3/3   Running
#   # sidecar-native        3/3   Running
#
# VIEW MAIN APP LOGS:
#   kubectl logs sidecar-traditional -c app
#   kubectl logs sidecar-native -c app
#
# VIEW SIDECAR LOGS:
#   kubectl logs sidecar-traditional -c log-shipper
#   kubectl logs sidecar-traditional -c log-analyzer
#
# FOLLOW LOGS IN REAL-TIME:
#   kubectl logs sidecar-traditional -c log-shipper -f
#
# CLEANUP:
#   kubectl delete pod sidecar-traditional sidecar-native
#
# ============================================================================
# BASH COMMAND QUICK REFERENCE
# ============================================================================
#
# COMMAND                 | MEANING
# ------------------------|--------------------------------------------------
# sh -c "..."             | Run string as shell command
# |                       | Multi-line string in YAML
# echo "text"             | Print text to stdout
# >> file                 | Append to file (create if doesn't exist)
# > file                  | Overwrite file (create if doesn't exist)
# $(date)                 | Current date/time
# $RANDOM                 | Random number 0-32767
# $((expr))               | Arithmetic: $((5 + 3)) = 8
# while true; do..done    | Infinite loop
# [ -f file ]             | True if file exists
# [ ! -f file ]           | True if file does NOT exist
# [ -z "$var" ]           | True if variable is empty
# sleep N                 | Wait N seconds
# tail -f file            | Follow file in real-time
# grep -q "pattern"       | Search quietly (no output)
# "A\|B"                  | Match A OR B in grep
# cmd1 | cmd2             | Pipe output of cmd1 to cmd2
# if ..; then ..; fi      | Conditional
# continue                | Skip to next loop iteration
#
# ============================================================================
